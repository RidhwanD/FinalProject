------------------------------ MODULE GDH3_mx ------------------------------

EXTENDS Integers, TLC, Sequences, ModExp, ExtendedEuclid

\* CekInverse(i,p) == \E j \in 1..(p-1) : i * j % p = 1         (* Check wether i has inverse in Fp *)
\* Inverse(i,p) == CHOOSE j \in 1..(p-1) : i * j % p = 1        (* Calculate the inverse of i in Fp *)

VARIABLES a0, a1, a2, a3, ia0, ia1, ia2, ia3, g, x0, x1, x2, x3, h0, h1, h2, h3, bl, ck0, ck1, 
ck2, ck3, pc, p, key

vars == << a0, a1, a2, a3, ia0, ia1, ia2, ia3, g, x0, x1, x2, x3, h0, h1, h2, h3, bl, ck0, ck1, 
ck2, ck3, pc, p, key >>

Init == (* Global variables *)
        /\ a0 \in Nat                       (* Secret exponent of P0 *)
        /\ a1 \in Nat                       (* Secret exponent of P1 *)
        /\ a2 \in Nat                       (* Secret exponent of P2 *)
        /\ a3 \in Nat                       (* Secret exponent of P3 *)
        /\ p = 13                           (* Finite field size *)
        /\ g = 2                            (* Generator of Fp *)
        /\ key = mod_exp(a3,mod_exp(a2,mod_exp(a1,mod_exp(a0,g,1,p),1,p),1,p),1,p) (* Shared key *)
        /\ IF CekInverse(a0,p-1) /\ CekInverse(a1,p-1) 
           /\ CekInverse(a2,p-1) /\ CekInverse(a3,p-1)  
                                            (* Check wether all secret exponent have inverse in T(p) *)
            THEN /\ ia0 = Inverse(a0,p-1)   (* If so, calculates the inverse of a0 *)
                 /\ ia1 = Inverse(a1,p-1)   (* calculates the inverse of a1 *)
                 /\ ia2 = Inverse(a2,p-1)   (* calculates the inverse of a2 *)
                 /\ ia3 = Inverse(a3,p-1)   (* calculates the inverse of a3 *)
                 /\ pc = "Upflow"           (* and the key exchange is possible *)
            ELSE /\ TRUE
                 /\ ia0 = 0                 (* Else, the inverse is 0 *)
                 /\ ia1 = 0
                 /\ ia2 = 0
                 /\ ia3 = 0
                 /\ pc = "No Key"           (* and the key exchange is not possible *)
        /\ x0 = 0                           (* Value computed by P0 *)
        /\ x1 = 0                           (* Value computed by P1 *)
        /\ x2 = 0                           (* Value computed by P2 *)
        /\ x3 = 0                           (* Value computed by P3 *)
        /\ h0 = 0                           (* Number of message received by P0 *)
        /\ h1 = 0                           (* Number of message received by P1 *)
        /\ h2 = 0                           (* Number of message received by P2 *)
        /\ h3 = 0                           (* Number of message received by P3 *)
        /\ bl = <<>>                        (* Broadcast list generated by P3 *)        
        /\ ck0 = FALSE                      (* Boolean to indicate that P0 has received the common key *)
        /\ ck1 = FALSE                      (* Boolean to indicate that P1 has received the common key *)
        /\ ck2 = FALSE                      (* Boolean to indicate that P2 has received the common key *)
        /\ ck3 = FALSE                      (* Boolean to indicate that P3 has received the common key *)
        
Upflow == /\ pc = "Upflow"
          /\ x0' = mod_exp(a0,g,1,p)        (* P0 calculates x0 = g ^ a0 mod p and sends it to P1 *)
          /\ h1' = h1 + 1                   (* P1 receives x0 from P0, h1 increases by 1 *)
          /\ x1' = mod_exp(a1,x0',1,p)      (* P1 calculates x1 = x0 ^ a1 mod p and sends it to P2 *)
          /\ h2' = h2 + 1                   (* P2 receives x1 from P1, h2 increases by 1 *)
          /\ x2' = mod_exp(a2,x1',1,p)      (* P1 calculates x2 = x1 ^ a2 mod p and broadcasts it to other participants *)
          /\ h3' = h3 + 1                   (* P3 receives x2 from P2, h3 increases by 1 *)
          /\ x3' = mod_exp(a3,x2',1,p)      (* P1 calculates x3 = x2 ^ a3 mod p as its mutual key *)
          /\ IF x0' = key /\ h0 = 2         (* If x0 equals the key and P0 has received two messages from others *)
                THEN /\ ck0' = TRUE         (* then ck0 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck0' = ck0
          /\ IF x1' = key /\ h1' = 3        (* If x1 equals the key and P1 has received three messages from others *)
                THEN /\ ck1' = TRUE         (* then ck1 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck1' = ck1
          /\ IF x2' = key /\ h2' = 2        (* If x2 equals the key and P2 has received two messages from others *)
                THEN /\ ck2' = TRUE         (* then ck2 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck2' = ck2
          /\ IF x3' = key /\ h3' = 1        (* If x3 equals the key and P3 has received one message from others *)
                THEN /\ ck3' = TRUE         (* then ck3 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck3' = ck3
          /\ pc' = "Broadcast1"             (* Upflow phase is finished. Starts the first broadcast phase *)
          /\ UNCHANGED << a0, a1, a2, a3, ia0, 
             ia1, ia2, ia3, g, p, key, bl, h0 >>   
                                            (* The value of these variables are unchanged in this state *)

Broadcast1 == /\ pc = "Broadcast1"
              /\ x0' = x2                   (* P0 receives x2 from P2 *)
              /\ h0' = h0 + 1               (* h0 increased by 1 *)
              /\ x1' = x2                   (* P1 receives x2 from P2 *)
              /\ h1' = h1 + 1               (* h0 increased by 1 *)
              /\ IF x0' = key /\ h0' = 2    (* If x0 equals the key and P0 has received two messages from others *)
                    THEN /\ ck0' = TRUE     (* then ck0 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck0' = ck0
              /\ IF x1' = key /\ h1' = 3    (* If x1 equals the key and P1 has received three messages from others *)
                    THEN /\ ck1' = TRUE     (* then ck1 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck1' = ck1
              /\ IF x2 = key /\ h2 = 2      (* If x2 equals the key and P2 has received two messages from others *)
                    THEN /\ ck2' = TRUE     (* then ck2 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck2' = ck2
              /\ IF x3 = key /\ h3 = 1      (* If x3 equals the key and P3 has received one message from others *)
                    THEN /\ ck3' = TRUE     (* then ck3 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck3' = ck3
              /\ pc' = "Response"           (* The first broadcast phase is finished. Starts the response phase *)
              /\ UNCHANGED << a0, a1, a2, a3, ia0, ia1, ia2, 
                 ia3, g, p, key, bl, x2, h2, x3, h3 >>   
                                            (* The value of these variables are unchanged in this state *)
       
Response == /\ pc = "Response"
            /\ x0' = mod_exp(ia0,x0,1,p)    (* P0 calculates x0 = x0 ^ ia0 mod p and sends it to P3 *)
            /\ x1' = mod_exp(ia1,x1,1,p)    (* P1 calculates x1 = x1 ^ ia1 mod p and sends it to P3 *)
            /\ x2' = mod_exp(ia2,x2,1,p)    (* P2 calculates x2 = x2 ^ ia2 mod p and sends it to P3 *)
            /\ h3' = h3 + 3                 (* P3 receives three message from P0, P1, and P2. h3 increases by 3 *)
            /\ bl' = << mod_exp(a3,x0',1,p), mod_exp(a3,x1',1,p), mod_exp(a3,x2',1,p) >>  
                                            (* P3 constructs a broadcast list bl and sends it to other participants *)
            /\ IF x0' = key /\ h0 = 2       (* If x0 equals the key and P0 has received two messages from others *)
                  THEN /\ ck0' = TRUE       (* then ck0 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck0' = ck0
            /\ IF x1' = key /\ h1 = 3       (* If x1 equals the key and P1 has received three messages from others *)
                  THEN /\ ck1' = TRUE       (* then ck1 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck1' = ck1
            /\ IF x2' = key /\ h2 = 2       (* If x2 equals the key and P2 has received two messages from others *)
                  THEN /\ ck2' = TRUE       (* then ck2 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck2' = ck2
            /\ IF x3 = key /\ h3' = 1       (* If x3 equals the key and P3 has received one message from others *)
                  THEN /\ ck3' = TRUE       (* then ck3 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck3' = ck3
            /\ pc' = "Broadcast2"           (* The response phase is finished. Starts the second broadcast phase *)
            /\ UNCHANGED << a0, a1, a2, a3, ia0, ia1, ia2, 
               ia3, g, p, key, h0, h1, h2, x3 >>   
                                            (* The value of these variables are unchanged in this state *)
            
Broadcast2 == /\ pc = "Broadcast2"
              /\ h0' = h0 + 1               (* P0 receives bl from P3. h0 increases by 1 *)
              /\ x0' = mod_exp(a0,bl[1],1,p)(* P0 calculates x0 = bl[1] ^ a0 mod p as its mutual key *)
              /\ h1' = h1 + 1               (* P1 receives bl from P3. h1 increases by 1 *)
              /\ x1' = mod_exp(a1,bl[2],1,p)(* P1 calculates x1 = bl[2] ^ a1 mod p as its mutual key *)
              /\ h2' = h2 + 1               (* P2 receives bl from P3. h2 increases by 1 *)
              /\ x2' = mod_exp(a2,bl[3],1,p)(* P2 calculates x2 = bl[3] ^ a2 mod p as its mutual key *)
              /\ IF x0' = key /\ h0' = 2    (* If x0 equals the key and P0 has received two messages from others *)
                    THEN /\ ck0' = TRUE     (* then ck0 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck0' = ck0
              /\ IF x1' = key /\ h1' = 3    (* If x1 equals the key and P1 has received three messages from others *)
                    THEN /\ ck1' = TRUE     (* then ck1 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck1' = ck1
              /\ IF x2' = key /\ h2' = 2    (* If x2 equals the key and P2 has received two messages from others *)
                    THEN /\ ck2' = TRUE     (* then ck2 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck2' = ck2
              /\ IF x3 = key /\ h3 = 1      (* If x3 equals the key and P3 has received one message from others *)
                    THEN /\ ck3' = TRUE     (* then ck3 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck3' = ck3
              /\ pc' = "Done"               (* The key exchange is done *)
              /\ UNCHANGED << a0, a1, a2, a3, ia0, ia1, 
                 ia2, ia3, g, p, bl, key, x3, h3 >>   
                                            (* The value of these variables are unchanged in this state *)

NoKey == /\ pc = "No Key"                   (* If the key exchange is not possible, all cki is assigned to TRUE *)
         /\ ck0' = TRUE                     (* to avoid temporal formula violation *)
         /\ ck1' = TRUE
         /\ ck2' = TRUE
         /\ ck3' = TRUE
         /\ pc' = "Done"
         /\ UNCHANGED << a0, a1, a2, a3, ia0, ia1, ia2, 
            ia3, key, g, x0, x1, x2, x3, bl, p, h0, h1, h2, h3 >>   
                                            (* The value of these variables are unchanged in this state *)

Next == Upflow \/ Broadcast1 \/ Response \/ Broadcast2 \/ NoKey
           \/ (* Disjunct to prevent deadlock on termination *)
              (pc = "Done" /\ UNCHANGED vars)

Spec == /\ Init /\ [][Next]_vars
        /\ WF_vars(Next)

(* Checking termination *)
Termination == <>(pc = "Done")     

(* Checking wether all participants eventually receive the key at the same time *)
SameTime == (<>(ck0 /\ ck1 /\ ck2 /\ ck3)) /\ (~<>(ck0 /\ (~ck1 \/ ~ck2 \/ ~ck3))) 
/\ (~<>(ck1 /\ (~ck0 \/ ~ck2 \/ ~ck3))) /\ (~<>(ck2 /\ (~ck0 \/ ~ck1 \/ ~ck3))) 
/\ (~<>(ck3 /\ (~ck0 \/ ~ck1 \/ ~ck2)))

(* Checking wether all participants eventually receive the key *)
GetMutualKey == (<>ck0) /\ (<>ck1) /\ (<>ck2) /\ (<>ck3)

=============================================================================
\* Modification History
\* Last modified Fri May 25 17:23:27 ICT 2018 by Emp. Elesar II
\* Created Wed May 23 16:14:27 ICT 2018 by Emp. Elesar II
