------------------------------- MODULE GDH3_8 -------------------------------

EXTENDS Integers, TLC, Sequences, ModExp, ExtendedEuclid

\* CekInverse(i,p) == \E j \in 1..(p-1) : i * j % p = 1         (* Check wether i has inverse in Fp *)
\* Inverse(i,p) == CHOOSE j \in 1..(p-1) : i * j % p = 1        (* Calculate the inverse of i in Fp *)

VARIABLES a0, a1, a2, a3, a4, a5, a6, a7, ia0, ia1, ia2, ia3, ia4, ia5, ia6, ia7, g, 
x0, x1, x2, x3, x4, x5, x6, x7, h0, h1, h2, h3, h4, h5, h6, h7, bl, 
ck0, ck1, ck2, ck3, ck4, ck5, ck6, ck7, pc, p, key

vars == << a0, a1, a2, a3, a4, a5, a6, a7, ia0, ia1, ia2, ia3, ia4, ia5, ia6, ia7, g, 
x0, x1, x2, x3, x4, x5, x6, x7, h0, h1, h2, h3, h4, h5, h6, h7, bl, 
ck0, ck1, ck2, ck3, ck4, ck5, ck6, ck7, pc, p, key >>

Init == (* Global variables *)
        /\ a0 \in Nat                       (* Secret exponent of S0 *)
        /\ a1 \in Nat                       (* Secret exponent of S1 *)
        /\ a2 \in Nat                       (* Secret exponent of S2 *)
        /\ a3 \in Nat                       (* Secret exponent of S3 *)
        /\ a4 \in Nat                       (* Secret exponent of S4 *)
        /\ a5 \in Nat                       (* Secret exponent of S5 *)
        /\ a6 \in Nat                       (* Secret exponent of S6 *)
        /\ a7 \in Nat                       (* Secret exponent of S7 *)
        /\ p = 13                           (* Finite field size *)
        /\ g = 2                            (* Generator of Fp *)
        /\ key = mod_exp(a7,mod_exp(a6,mod_exp(a5,mod_exp(a4,mod_exp(a3,mod_exp(a2,mod_exp(a1,mod_exp(a0,g,1,p),1,p),1,p),1,p),1,p),1,p),1,p),1,p) 
                            (* Shared key *)
        /\ IF InverseCheck(a0,p-1) /\ InverseCheck(a1,p-1) /\ InverseCheck(a2,p-1) /\ InverseCheck(a3,p-1) 
           /\ InverseCheck(a4,p-1) /\ InverseCheck(a5,p-1) /\ InverseCheck(a6,p-1) /\ InverseCheck(a7,p-1) 
                                            (* Check wether all secret exponent have inverse in T(p) *)
            THEN /\ ia0 = Inverse(a0,p-1)   (* If so, calculates the inverse of a0 *)
                 /\ ia1 = Inverse(a1,p-1)   (* calculates the inverse of a1 *)
                 /\ ia2 = Inverse(a2,p-1)   (* calculates the inverse of a2 *)
                 /\ ia3 = Inverse(a3,p-1)   (* calculates the inverse of a3 *)
                 /\ ia4 = Inverse(a4,p-1)   (* calculates the inverse of a4 *)
                 /\ ia5 = Inverse(a5,p-1)   (* calculates the inverse of a5 *)
                 /\ ia6 = Inverse(a6,p-1)   (* calculates the inverse of a6 *)
                 /\ ia7 = Inverse(a7,p-1)   (* calculates the inverse of a7 *)
                 /\ pc = "Upflow"           (* and the key exchange is possible *)
            ELSE /\ TRUE
                 /\ ia0 = 0                 (* Else, the inverse is 0 *)
                 /\ ia1 = 0
                 /\ ia2 = 0
                 /\ ia3 = 0
                 /\ ia4 = 0
                 /\ ia5 = 0
                 /\ ia6 = 0
                 /\ ia7 = 0
                 /\ pc = "No Key"           (* and the key exchange is not possible *)
        /\ x0 = 0           (* Value computed by S0 *)
        /\ x1 = 0           (* Value computed by S1 *)
        /\ x2 = 0           (* Value computed by S2 *)
        /\ x3 = 0           (* Value computed by S3 *)
        /\ x4 = 0           (* Value computed by S4 *)
        /\ x5 = 0           (* Value computed by S5 *)
        /\ x6 = 0           (* Value computed by S6 *)
        /\ x7 = 0           (* Value computed by S7 *)
        /\ h0 = 0           (* Number of message received by S0 *)
        /\ h1 = 0           (* Number of message received by S1 *)
        /\ h2 = 0           (* Number of message received by S2 *)
        /\ h3 = 0           (* Number of message received by S3 *)
        /\ h4 = 0           (* Number of message received by S4 *)
        /\ h5 = 0           (* Number of message received by S5 *)
        /\ h6 = 0           (* Number of message received by S6 *)
        /\ h7 = 0           (* Number of message received by S7 *)
        /\ ck0 = FALSE      (* Boolean to indicate that S0 has received the common key *)
        /\ ck1 = FALSE      (* Boolean to indicate that S1 has received the common key *)
        /\ ck2 = FALSE      (* Boolean to indicate that S2 has received the common key *)
        /\ ck3 = FALSE      (* Boolean to indicate that S3 has received the common key *)
        /\ ck4 = FALSE      (* Boolean to indicate that S4 has received the common key *)
        /\ ck5 = FALSE      (* Boolean to indicate that S5 has received the common key *)
        /\ ck6 = FALSE      (* Boolean to indicate that S6 has received the common key *)
        /\ ck7 = FALSE      (* Boolean to indicate that S7 has received the common key *)
        /\ bl = <<>>        (* Broadcast list generated by S3 *)        
        
Upflow == /\ pc = "Upflow"
          /\ x0' = mod_exp(a0,g,1,p)        (* S0 calculates x0 = g ^ a0 mod p and sends it to S1 *)
          /\ h1' = h1 + 1                   (* S1 receives x0 from S0, h1 increases by 1 *)
          /\ x1' = mod_exp(a1,x0',1,p)      (* S1 calculates x1 = x0 ^ a1 mod p and sends it to S2 *)
          /\ h2' = h2 + 1                   (* S2 receives x1 from S1, h2 increases by 1 *)
          /\ x2' = mod_exp(a2,x1',1,p)      (* S2 calculates x2 = x1 ^ a2 mod p and sends it to S3 *)
          /\ h3' = h3 + 1                   (* S3 receives x2 from S2, h3 increases by 1 *)
          /\ x3' = mod_exp(a3,x2',1,p)      (* S3 calculates x3 = x2 ^ a3 mod p and sends it to S4 *)
          /\ h4' = h4 + 1                   (* S4 receives x3 from S3, h4 increases by 1 *)
          /\ x4' = mod_exp(a4,x3',1,p)      (* S4 calculates x4 = x3 ^ a4 mod p and sends it to S5 *)
          /\ h5' = h5 + 1                   (* S5 receives x4 from S4, h5 increases by 1 *)
          /\ x5' = mod_exp(a5,x4',1,p)      (* S5 calculates x5 = x4 ^ a5 mod p and sends it to S6 *)
          /\ h6' = h6 + 1                   (* S6 receives x5 from S5, h6 increases by 1 *)
          /\ x6' = mod_exp(a6,x5',1,p)      (* S6 calculates x6 = x5 ^ a6 mod p and broadcasts it to other participants *)
          /\ h7' = h7 + 1                   (* S7 receives x6 from S6, h7 increases by 1 *)
          /\ x7' = mod_exp(a7,x6',1,p)      (* S7 calculates x7 = x6 ^ a7 mod p as its mutual key *)
          
          /\ IF x0' = key /\ h0 = 2         (* If x0 equals the key and S0 has received two messages from others *)
                THEN /\ ck0' = TRUE         (* then ck0 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck0' = ck0
          /\ IF x1' = key /\ h1' = 3        (* If x1 equals the key and S1 has received three messages from others *)
                THEN /\ ck1' = TRUE         (* then ck1 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck1' = ck1
          /\ IF x2' = key /\ h2' = 3        (* If x2 equals the key and S2 has received three messages from others *)
                THEN /\ ck2' = TRUE         (* then ck2 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck2' = ck2
          /\ IF x3' = key /\ h3' = 3        (* If x3 equals the key and S3 has received three messages from others *)
                THEN /\ ck3' = TRUE         (* then ck3 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck3' = ck3
          /\ IF x4' = key /\ h4' = 3        (* If x4 equals the key and S4 has received three messages from others *)
                THEN /\ ck4' = TRUE         (* then ck4 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck4' = ck4
          /\ IF x5' = key /\ h5' = 3        (* If x5 equals the key and S5 has received three messages from others *)
                THEN /\ ck5' = TRUE         (* then ck5 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck5' = ck5
          /\ IF x6' = key /\ h6' = 2        (* If x6 equals the key and S6 has received two messages from others *)
                THEN /\ ck6' = TRUE         (* then ck6 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck6' = ck6
          /\ IF x7' = key /\ h7' = 1        (* If x7 equals the key and S7 has received one message from others *)
                THEN /\ ck7' = TRUE         (* then ck7 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck7' = ck7
          
          /\ pc' = "Broadcast1"             (* Upflow phase is finished. Starts the first broadcast phase *)
          /\ UNCHANGED << a0, a1, a2, a3, a4, a5, a6, a7, ia0, ia1, ia2, ia3, ia4, ia5, ia6, ia7, g, p, key, bl, h0 >>   
                                            (* The value of these variables are unchanged in this state *)

Broadcast1 == /\ pc = "Broadcast1"
              /\ x0' = x6                   (* S0 receives x6 from S6 *)
              /\ h0' = h0 + 1               (* h0 increased by 1 *)
              /\ x1' = x6                   (* S1 receives x6 from S6 *)
              /\ h1' = h1 + 1               (* h1 increased by 1 *)
              /\ x2' = x6                   (* S2 receives x6 from S6 *)
              /\ h2' = h2 + 1               (* h2 increased by 1 *)
              /\ x3' = x6                   (* S3 receives x6 from S6 *)
              /\ h3' = h3 + 1               (* h3 increased by 1 *)
              /\ x4' = x6                   (* S4 receives x6 from S6 *)
              /\ h4' = h4 + 1               (* h4 increased by 1 *)
              /\ x5' = x6                   (* S5 receives x6 from S6 *)
              /\ h5' = h5 + 1               (* h5 increased by 1 *)
              
              /\ IF x0' = key /\ h0' = 2        (* If x0 equals the key and S0 has received two messages from others *)
                    THEN /\ ck0' = TRUE         (* then ck0 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck0' = ck0
              /\ IF x1' = key /\ h1' = 3        (* If x1 equals the key and S1 has received three messages from others *)
                    THEN /\ ck1' = TRUE         (* then ck1 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck1' = ck1
              /\ IF x2' = key /\ h2' = 3        (* If x2 equals the key and S2 has received three messages from others *)
                    THEN /\ ck2' = TRUE         (* then ck2 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck2' = ck2
              /\ IF x3' = key /\ h3' = 3        (* If x3 equals the key and S3 has received three messages from others *)
                    THEN /\ ck3' = TRUE         (* then ck3 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck3' = ck3
              /\ IF x4' = key /\ h4' = 3        (* If x4 equals the key and S4 has received three messages from others *)
                    THEN /\ ck4' = TRUE         (* then ck4 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck4' = ck4
              /\ IF x5' = key /\ h5' = 3        (* If x5 equals the key and S5 has received three messages from others *)
                    THEN /\ ck5' = TRUE         (* then ck5 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck5' = ck5
              /\ IF x6 = key /\ h6 = 2          (* If x6 equals the key and S6 has received two messages from others *)
                    THEN /\ ck6' = TRUE         (* then ck6 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck6' = ck6
              /\ IF x7 = key /\ h7 = 1          (* If x7 equals the key and S7 has received one message from others *)
                    THEN /\ ck7' = TRUE         (* then ck7 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck7' = ck7
          
              /\ pc' = "Response"           (* The first broadcast phase is finished. Starts the response phase *)
              /\ UNCHANGED << a0, a1, a2, a3, a4, a5, a6, a7, ia0, ia1, ia2, ia3, ia4, ia5, ia6, ia7,
                 g, p, key, bl, x6, h6, x7, h7 >>   
                                            (* The value of these variables are unchanged in this state *)
       
Response == /\ pc = "Response"
            /\ x0' = mod_exp(ia0,x0,1,p)    (* S0 calculates x0 = x0 ^ ia0 mod p and sends it to S7 *)
            /\ x1' = mod_exp(ia1,x1,1,p)    (* S1 calculates x1 = x1 ^ ia1 mod p and sends it to S7 *)
            /\ x2' = mod_exp(ia2,x2,1,p)    (* S2 calculates x2 = x2 ^ ia2 mod p and sends it to S7 *)
            /\ x3' = mod_exp(ia3,x3,1,p)    (* S3 calculates x3 = x3 ^ ia3 mod p and sends it to S7 *)
            /\ x4' = mod_exp(ia4,x4,1,p)    (* S4 calculates x4 = x4 ^ ia4 mod p and sends it to S7 *)
            /\ x5' = mod_exp(ia5,x5,1,p)    (* S5 calculates x5 = x5 ^ ia5 mod p and sends it to S7 *)
            /\ x6' = mod_exp(ia6,x6,1,p)    (* S6 calculates x6 = x6 ^ ia6 mod p and sends it to S7 *)
            /\ h7' = h7 + 7                 (* S7 receives seven message from other participants. h3 increases by 7 *)
            /\ bl' = << mod_exp(a7,x0',1,p), mod_exp(a7,x1',1,p), mod_exp(a7,x2',1,p), mod_exp(a7,x3',1,p), mod_exp(a7,x4',1,p), mod_exp(a7,x5',1,p), mod_exp(a7,x6',1,p) >>  
                                            (* S7 constructs a broadcast list bl and sends it to other participants *)
            
            /\ IF x0' = key /\ h0 = 2         (* If x0 equals the key and S0 has received two messages from others *)
                  THEN /\ ck0' = TRUE         (* then ck0 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck0' = ck0
            /\ IF x1' = key /\ h1 = 3         (* If x1 equals the key and S1 has received three messages from others *)
                  THEN /\ ck1' = TRUE         (* then ck1 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck1' = ck1
            /\ IF x2' = key /\ h2 = 3         (* If x2 equals the key and S2 has received three messages from others *)
                  THEN /\ ck2' = TRUE         (* then ck2 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck2' = ck2
            /\ IF x3' = key /\ h3 = 3         (* If x3 equals the key and S3 has received three messages from others *)
                  THEN /\ ck3' = TRUE         (* then ck3 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck3' = ck3
            /\ IF x4' = key /\ h4 = 3         (* If x4 equals the key and S4 has received three messages from others *)
                  THEN /\ ck4' = TRUE         (* then ck4 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck4' = ck4
            /\ IF x5' = key /\ h5 = 3         (* If x5 equals the key and S5 has received three messages from others *)
                  THEN /\ ck5' = TRUE         (* then ck5 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck5' = ck5
            /\ IF x6' = key /\ h6 = 2         (* If x6 equals the key and S6 has received two messages from others *)
                  THEN /\ ck6' = TRUE         (* then ck6 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck6' = ck6
            /\ IF x7 = key /\ h7' = 1         (* If x7 equals the key and S7 has received one message from others *)
                  THEN /\ ck7' = TRUE         (* then ck7 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck7' = ck7
          
            /\ pc' = "Broadcast2"           (* The response phase is finished. Starts the second broadcast phase *)
            /\ UNCHANGED << a0, a1, a2, a3, a4, a5, a6, a7, ia0, ia1, ia2, ia3, ia4, ia5, ia6, ia7,
               g, p, key, h0, h1, h2, h3, h4, h5, h6, x7 >>   
                                            (* The value of these variables are unchanged in this state *)
            
Broadcast2 == /\ pc = "Broadcast2"
              /\ h0' = h0 + 1               (* S0 receives bl from S7. h0 increases by 1 *)
              /\ x0' = mod_exp(a0,bl[1],1,p)(* S0 calculates x0 = bl[1] ^ a0 mod p as its mutual key *)
              /\ h1' = h1 + 1               (* S1 receives bl from S7. h1 increases by 1 *)
              /\ x1' = mod_exp(a1,bl[2],1,p)(* S1 calculates x1 = bl[2] ^ a1 mod p as its mutual key *)
              /\ h2' = h2 + 1               (* S2 receives bl from S7. h2 increases by 1 *)
              /\ x2' = mod_exp(a2,bl[3],1,p)(* S2 calculates x2 = bl[3] ^ a2 mod p as its mutual key *)
              /\ h3' = h3 + 1               (* S3 receives bl from S7. h3 increases by 1 *)
              /\ x3' = mod_exp(a3,bl[4],1,p)(* S3 calculates x3 = bl[4] ^ a3 mod p as its mutual key *)
              /\ h4' = h4 + 1               (* S4 receives bl from S7. h4 increases by 1 *)
              /\ x4' = mod_exp(a4,bl[5],1,p)(* S4 calculates x4 = bl[5] ^ a4 mod p as its mutual key *)
              /\ h5' = h5 + 1               (* S5 receives bl from S7. h5 increases by 1 *)
              /\ x5' = mod_exp(a5,bl[6],1,p)(* S5 calculates x5 = bl[6] ^ a5 mod p as its mutual key *)
              /\ h6' = h6 + 1               (* S6 receives bl from S7. h6 increases by 1 *)
              /\ x6' = mod_exp(a6,bl[7],1,p)(* S6 calculates x6 = bl[7] ^ a6 mod p as its mutual key *)
              
              /\ IF x0' = key /\ h0' = 2        (* If x0 equals the key and S0 has received two messages from others *)
                    THEN /\ ck0' = TRUE         (* then ck0 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck0' = ck0
              /\ IF x1' = key /\ h1' = 3        (* If x1 equals the key and S1 has received three messages from others *)
                    THEN /\ ck1' = TRUE         (* then ck1 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck1' = ck1
              /\ IF x2' = key /\ h2' = 3        (* If x2 equals the key and S2 has received three messages from others *)
                    THEN /\ ck2' = TRUE         (* then ck2 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck2' = ck2
              /\ IF x3' = key /\ h3' = 3        (* If x3 equals the key and S3 has received three messages from others *)
                    THEN /\ ck3' = TRUE         (* then ck3 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck3' = ck3
              /\ IF x4' = key /\ h4' = 3        (* If x4 equals the key and S4 has received three messages from others *)
                    THEN /\ ck4' = TRUE         (* then ck4 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck4' = ck4
              /\ IF x5' = key /\ h5' = 3        (* If x5 equals the key and S5 has received three messages from others *)
                    THEN /\ ck5' = TRUE         (* then ck5 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck5' = ck5
              /\ IF x6' = key /\ h6' = 2        (* If x6 equals the key and S6 has received two messages from others *)
                    THEN /\ ck6' = TRUE         (* then ck6 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck6' = ck6
              /\ IF x7 = key /\ h7 = 1          (* If x7 equals the key and S7 has received one message from others *)
                    THEN /\ ck7' = TRUE         (* then ck7 becomes TRUE *)
                    ELSE /\ TRUE
                         /\ ck7' = ck7
          
              /\ pc' = "Done"               (* The key exchange is done *)
              /\ UNCHANGED << a0, a1, a2, a3, a4, a5, a6, a7, ia0, ia1, ia2, ia3, ia4, ia5, ia6, ia7,
                 g, p, bl, key, x7, h7 >>   
                                            (* The value of these variables are unchanged in this state *)

NoKey == /\ pc = "No Key"                   (* If the key exchange is not possible, all cki is assigned to TRUE *)
         /\ ck0' = TRUE                     (* to avoid temporal formula violation *)
         /\ ck1' = TRUE
         /\ ck2' = TRUE
         /\ ck3' = TRUE
         /\ ck4' = TRUE
         /\ ck5' = TRUE
         /\ ck6' = TRUE
         /\ ck7' = TRUE
         /\ pc' = "Done"
         /\ UNCHANGED << a0, a1, a2, a3, a4, a5, a6, a7, ia0, ia1, ia2, ia3, ia4, ia5, ia6, ia7,
            key, g, x0, x1, x2, x3, x4, x5, x6, x7, bl, p, h0, h1, h2, h3, h4, h5, h6, h7 >>   
                                            (* The value of these variables are unchanged in this state *)

Next == Upflow \/ Broadcast1 \/ Response \/ Broadcast2 \/ NoKey
           \/ (* Disjunct to prevent deadlock on termination *)
              (pc = "Done" /\ UNCHANGED vars)

Spec == /\ Init /\ [][Next]_vars
        /\ WF_vars(Next)

(* Checking termination *)
Termination == <>(pc = "Done")     

(* Checking wether all participants eventually receive the key at the same time *)
SameTime == (<>(ck0 /\ ck1 /\ ck2 /\ ck3 /\ ck4 /\ ck5 /\ ck6 /\ ck7)) 
/\ (~<>(ck0 /\ (~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7))) 
/\ (~<>(ck1 /\ (~ck0 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7))) 
/\ (~<>(ck2 /\ (~ck0 \/ ~ck1 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7))) 
/\ (~<>(ck3 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7)))
/\ (~<>(ck4 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck5 \/ ~ck6 \/ ~ck7)))
/\ (~<>(ck5 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck6 \/ ~ck7)))
/\ (~<>(ck6 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck7)))
/\ (~<>(ck7 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6)))

(* Checking wether all participants eventually receive the key *)
GetMutualKey == (<>ck0) /\ (<>ck1) /\ (<>ck2) /\ (<>ck3) /\ (<>ck4) /\ (<>ck5) /\ (<>ck6) /\ (<>ck7)  

=============================================================================
\* Modification History
\* Last modified Wed May 30 21:08:57 ICT 2018 by Emp. Elesar II
\* Created Wed May 30 20:42:36 ICT 2018 by Emp. Elesar II
