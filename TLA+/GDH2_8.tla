------------------------------- MODULE GDH2_8 -------------------------------

EXTENDS Integers, TLC, Sequences, ModExp

VARIABLES a0, a1, a2, a3, a4, a5, a6, a7, g, x0, x1, x2, x3, x4, x5, x6, x7, 
h0, h1, h2, h3, h4, h5, h6, h7, ul, ul2, ul3, ul4, ul5, ul6, ul7, bl, 
ck0, ck1, ck2, ck3, ck4, ck5, ck6, ck7, pc, p, key

vars == << a0, a1, a2, a3, a4, a5, a6, a7, g, x0, x1, x2, x3, x4, x5, x6, x7, 
h0, h1, h2, h3, h4, h5, h6, h7, ul, ul2, ul3, ul4, ul5, ul6, ul7, bl, 
ck0, ck1, ck2, ck3, ck4, ck5, ck6, ck7, pc, p, key >>

Init == (* Global variables *)
        /\ a0 \in Nat       (* Secret exponent of S0 *)
        /\ a1 \in Nat       (* Secret exponent of S1 *)
        /\ a2 \in Nat       (* Secret exponent of S2 *)
        /\ a3 \in Nat       (* Secret exponent of S3 *)
        /\ a4 \in Nat       (* Secret exponent of S4 *)
        /\ a5 \in Nat       (* Secret exponent of S5 *)
        /\ a6 \in Nat       (* Secret exponent of S6 *)
        /\ a7 \in Nat       (* Secret exponent of S7 *)
        /\ p = 13           (* Finite field size *)
        /\ g = 2            (* Generator of Fp *)
        /\ key = mod_exp(a7,mod_exp(a6,mod_exp(a5,mod_exp(a4,mod_exp(a3,mod_exp(a2,mod_exp(a1,mod_exp(a0,g,1,p),1,p),1,p),1,p),1,p),1,p),1,p),1,p) 
                            (* Shared key *)
        /\ x0 = 0           (* Value computed by S0 *)
        /\ x1 = 0           (* Value computed by S1 *)
        /\ x2 = 0           (* Value computed by S2 *)
        /\ x3 = 0           (* Value computed by S3 *)
        /\ x4 = 0           (* Value computed by S4 *)
        /\ x5 = 0           (* Value computed by S5 *)
        /\ x6 = 0           (* Value computed by S6 *)
        /\ x7 = 0           (* Value computed by S7 *)
        /\ h0 = 0           (* Number of message received by S0 *)
        /\ h1 = 0           (* Number of message received by S1 *)
        /\ h2 = 0           (* Number of message received by S2 *)
        /\ h3 = 0           (* Number of message received by S3 *)
        /\ h4 = 0           (* Number of message received by S4 *)
        /\ h5 = 0           (* Number of message received by S5 *)
        /\ h6 = 0           (* Number of message received by S6 *)
        /\ h7 = 0           (* Number of message received by S7 *)
        /\ ck0 = FALSE      (* Boolean to indicate that S0 has received the common key *)
        /\ ck1 = FALSE      (* Boolean to indicate that S1 has received the common key *)
        /\ ck2 = FALSE      (* Boolean to indicate that S2 has received the common key *)
        /\ ck3 = FALSE      (* Boolean to indicate that S3 has received the common key *)
        /\ ck4 = FALSE      (* Boolean to indicate that S4 has received the common key *)
        /\ ck5 = FALSE      (* Boolean to indicate that S5 has received the common key *)
        /\ ck6 = FALSE      (* Boolean to indicate that S6 has received the common key *)
        /\ ck7 = FALSE      (* Boolean to indicate that S7 has received the common key *)
        /\ ul = <<>>        (* Upflow list generated by S0 *)
        /\ ul2 = <<>>       (* Upflow list that has been updated by S1 *)
        /\ ul3 = <<>>       (* Upflow list that has been updated by S2 *)
        /\ ul4 = <<>>       (* Upflow list that has been updated by S3 *)
        /\ ul5 = <<>>       (* Upflow list that has been updated by S4 *)
        /\ ul6 = <<>>       (* Upflow list that has been updated by S5 *)
        /\ ul7 = <<>>       (* Upflow list that has been updated by S6 *)
        /\ bl = <<>>        (* Broadcast list generated by S3 *)        
        /\ ck0 = FALSE      (* Boolean to indicate that S0 has received the common key *)
        /\ ck1 = FALSE      (* Boolean to indicate that S1 has received the common key *)
        /\ ck2 = FALSE      (* Boolean to indicate that S2 has received the common key *)
        /\ ck3 = FALSE      (* Boolean to indicate that S3 has received the common key *)
        /\ pc = "Upflow"
        
Upflow == /\ pc = "Upflow" 
          /\ x0' = mod_exp(a0,g,1,p)    (* S0 calculates x0 = g ^ a0 mod p *)
          /\ ul' = <<x0'>>              (* S0 constructs the upflow list ul and sends it to S1*)
          /\ h1' = h1 + 1               (* S1 receives ul from S0, h1 increases by 1 *)
          /\ x1' = mod_exp(a1,ul'[1],1,p)(* S1 computes x1 = ul[1] ^ a1 mod p *)
          /\ ul2' = << x1', ul'[1], mod_exp(a1,g,1,p) >>   (* S1 updates upflow list ul as ul2 and sends it to S2 *)
          /\ h2' = h2 + 1               (* S2 receives ul2 from S1, h2 increases by 1 *)
          /\ x2' = mod_exp(a2,ul2'[1],1,p)(* S2 computes x2 = ul2[1] ^ a2 mod p *)
          /\ ul3' = << x2', ul2'[1], mod_exp(a2,ul2'[2],1,p), mod_exp(a2,ul2'[3],1,p) >>  
                                        (* S2 updates upflow list ul2 as ul3 and sends it to S3 *)
          /\ h3' = h3 + 1               (* S3 receives ul3 from S2, h3 increases by 1 *)
          /\ x3' = mod_exp(a3,ul3'[1],1,p)(* S3 computes x3 = ul3[1] ^ a3 mod p *)
          /\ ul4' = << x3', ul3'[1], mod_exp(a3,ul3'[2],1,p), mod_exp(a3,ul3'[3],1,p), mod_exp(a3,ul3'[4],1,p) >>  
                                        (* S3 updates upflow list ul3 as ul4 and sends it to S4 *)
          /\ h4' = h4 + 1               (* S4 receives ul4 from S3, h4 increases by 1 *)
          /\ x4' = mod_exp(a4,ul4'[1],1,p)(* S4 computes x4 = ul4[1] ^ a4 mod p *)
          /\ ul5' = << x4', ul4'[1], mod_exp(a4,ul4'[2],1,p), mod_exp(a4,ul4'[3],1,p), mod_exp(a4,ul4'[4],1,p), mod_exp(a4,ul4'[5],1,p) >>  
                                        (* S4 updates upflow list ul4 as ul5 and sends it to S5 *)
          /\ h5' = h5 + 1               (* S5 receives ul5 from S4, h5 increases by 1 *)
          /\ x5' = mod_exp(a5,ul5'[1],1,p)(* S5 computes x5 = ul5[1] ^ a5 mod p *)
          /\ ul6' = << x5', ul5'[1], mod_exp(a5,ul5'[2],1,p), mod_exp(a5,ul5'[3],1,p), mod_exp(a5,ul5'[4],1,p), mod_exp(a5,ul5'[5],1,p), mod_exp(a5,ul5'[6],1,p) >>  
                                        (* S5 updates upflow list ul5 as ul6 and sends it to S6 *)                                                            
          /\ h6' = h6 + 1               (* S6 receives ul6 from S5, h6 increases by 1 *)
          /\ x6' = mod_exp(a6,ul6'[1],1,p)(* S6 computes x6 = ul6[1] ^ a6 mod p *)
          /\ ul7' = << x6', ul6'[1], mod_exp(a6,ul6'[2],1,p), mod_exp(a6,ul6'[3],1,p), mod_exp(a6,ul6'[4],1,p), mod_exp(a6,ul6'[5],1,p), mod_exp(a6,ul6'[6],1,p), mod_exp(a6,ul6'[7],1,p) >>  
                                        (* S6 updates upflow list ul6 as ul7 and sends it to S7 *)
          /\ h7' = h7 + 1               (* S7 receives ul7 from S6, h7 increases by 1 *)
          /\ x7' = mod_exp(a7,ul7'[1],1,p)(* S7 computes x7 = ul7[1] ^ a7 mod p as its mutual key *)                              
          /\ bl' = << mod_exp(a7,ul7'[2],1,p), mod_exp(a7,ul7'[3],1,p), mod_exp(a7,ul7'[4],1,p), mod_exp(a7,ul7'[5],1,p), mod_exp(a7,ul7'[6],1,p), mod_exp(a7,ul7'[7],1,p), mod_exp(a7,ul7'[8],1,p) >>   
                                        (* S7 constructs broadcast list bl and broadcasts it to other participants *)
          
          /\ IF x0' = key /\ h0 = 1     (* If x0 equals key and S0 has received one message from others *)
                THEN /\ ck0' = TRUE     (* then ck0 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck0' = ck0
          /\ IF x1' = key /\ h1' = 2    (* If x1 equals key and S1 has received two messages from others *)
                THEN /\ ck1' = TRUE     (* then ck1 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck1' = ck1
          /\ IF x2' = key /\ h2' = 2    (* If x2 equals key and S2 has received two messages from others *)
                THEN /\ ck2' = TRUE     (* then ck2 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck2' = ck2
          /\ IF x3' = key /\ h3' = 2    (* If x3 equals key and S3 has received two messages from others *)
                THEN /\ ck3' = TRUE     (* then ck3 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck3' = ck3
          /\ IF x4' = key /\ h4' = 2    (* If x4 equals key and S4 has received two messages from others *)
                THEN /\ ck4' = TRUE     (* then ck4 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck4' = ck4
          /\ IF x5' = key /\ h5' = 2    (* If x5 equals key and S5 has received two messages from others *)
                THEN /\ ck5' = TRUE     (* then ck5 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck5' = ck5
          /\ IF x6' = key /\ h6' = 2    (* If x6 equals key and S6 has received two messages from others *)
                THEN /\ ck6' = TRUE     (* then ck6 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck6' = ck6
          /\ IF x7' = key /\ h7' = 1    (* If x7 equals key and S7 has received one message from others *)
                THEN /\ ck7' = TRUE     (* then ck7 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck7' = ck7
                     
          /\ pc' = "Broadcast"          (* The upflow phase is finished, starts broadcast phase *)
          /\ UNCHANGED << a0, a1, a2, a3, a4, a5, a6, a7, g, p, key, h0 >>   
                                        (* The value of these variables are unchanged in this state *)
          
Broadcast == /\ pc = "Broadcast"
             /\ h6' = h6 + 1            (* S6 receives bl from S7, h6 increases by 1 *)
             /\ x6' = mod_exp(a6,bl[1],1,p)(* S6 computes x6 = bl[1] ^ a6 mod p as its mutual key *)
             /\ h5' = h5 + 1            (* S5 receives bl from S7, h5 increases by 1 *)
             /\ x5' = mod_exp(a5,bl[2],1,p)(* S5 computes x5 = bl[2] ^ a5 mod p as its mutual key *)
             /\ h4' = h4 + 1            (* S4 receives bl from S7, h4 increases by 1 *)
             /\ x4' = mod_exp(a4,bl[3],1,p)(* S4 computes x4 = bl[3] ^ a4 mod p as its mutual key *)
             /\ h3' = h3 + 1            (* S3 receives bl from S7, h3 increases by 1 *)
             /\ x3' = mod_exp(a3,bl[4],1,p)(* S3 computes x3 = bl[4] ^ a3 mod p as its mutual key *)
             /\ h2' = h2 + 1            (* S2 receives bl from S7, h2 increases by 1 *)
             /\ x2' = mod_exp(a2,bl[5],1,p)(* S2 computes x2 = bl[5] ^ a2 mod p as its mutual key *)
             /\ h1' = h1 + 1            (* S1 receives bl from S7, h1 increases by 1 *)
             /\ x1' = mod_exp(a1,bl[6],1,p)(* S1 computes x1 = bl[6] ^ a1 mod p as its mutual key *)
             /\ h0' = h0 + 1            (* S0 receives bl from S7, h0 increases by 1 *)
             /\ x0' = mod_exp(a0,bl[7],1,p)(* S0 computes x0 = bl[7] ^ a0 mod p as its mutual key *)
             
             /\ IF x0' = key /\ h0' = 1    (* If x0 equals key and S0 has received one message from others *)
                    THEN /\ ck0' = TRUE     (* then ck0 becomes TRUE *)
                   ELSE /\ TRUE
                        /\ ck0' = ck0
             /\ IF x1' = key /\ h1' = 2    (* If x1 equals key and S1 has received two messages from others *)
                   THEN /\ ck1' = TRUE     (* then ck1 becomes TRUE *)
                   ELSE /\ TRUE
                        /\ ck1' = ck1
             /\ IF x2' = key /\ h2' = 2    (* If x2 equals key and S2 has received two messages from others *)
                 THEN /\ ck2' = TRUE     (* then ck2 becomes TRUE *)
                 ELSE /\ TRUE
                      /\ ck2' = ck2
             /\ IF x3' = key /\ h3' = 2    (* If x3 equals key and S3 has received two messages from others *)
                   THEN /\ ck3' = TRUE     (* then ck3 becomes TRUE *)
                   ELSE /\ TRUE
                        /\ ck3' = ck3
             /\ IF x4' = key /\ h4' = 2    (* If x4 equals key and S4 has received two messages from others *)
                   THEN /\ ck4' = TRUE     (* then ck4 becomes TRUE *)
                   ELSE /\ TRUE
                        /\ ck4' = ck4
             /\ IF x5' = key /\ h5' = 2    (* If x5 equals key and S5 has received two messages from others *)
                   THEN /\ ck5' = TRUE     (* then ck5 becomes TRUE *)
                   ELSE /\ TRUE
                        /\ ck5' = ck5
             /\ IF x6' = key /\ h6' = 2    (* If x6 equals key and S6 has received two messages from others *)
                   THEN /\ ck6' = TRUE     (* then ck6 becomes TRUE *)
                   ELSE /\ TRUE
                        /\ ck6' = ck6
             /\ IF x7 = key /\ h7 = 1      (* If x7 equals key and S7 has received one message from others *)
                   THEN /\ ck7' = TRUE     (* then ck7 becomes TRUE *)
                   ELSE /\ TRUE
                        /\ ck7' = ck7
              
             /\ pc' = "Done"             (* The key exchange is finished *)
             /\ UNCHANGED << a0, a1, a2, a3, a4, a5, a6, a7, g, p, ul, ul2, ul3, ul4, ul5, ul6, ul7, bl, key, x7, h7 >>   
                                         (* The value of these variables are unchanged in this state *)

Next == Upflow \/ Broadcast
           \/ (* Disjunct to prevent deadlock on termination *)
              (pc = "Done" /\ UNCHANGED vars)

Spec == /\ Init /\ [][Next]_vars
        /\ WF_vars(Next)

(* Checking termination *)
Termination == <>(pc = "Done")     

(* Checking wether all participants eventually receive the key at the same time *)
SameTime == (<>(ck0 /\ ck1 /\ ck2 /\ ck3 /\ ck4 /\ ck5 /\ ck6 /\ ck7)) 
/\ (~<>(ck0 /\ (~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7))) 
/\ (~<>(ck1 /\ (~ck0 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7))) 
/\ (~<>(ck2 /\ (~ck0 \/ ~ck1 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7))) 
/\ (~<>(ck3 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7)))
/\ (~<>(ck4 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck5 \/ ~ck6 \/ ~ck7)))
/\ (~<>(ck5 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck6 \/ ~ck7)))
/\ (~<>(ck6 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck7)))
/\ (~<>(ck7 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6)))

(* Checking wether all participants eventually receive the key *)
GetMutualKey == (<>ck0) /\ (<>ck1) /\ (<>ck2) /\ (<>ck3) /\ (<>ck4) /\ (<>ck5) /\ (<>ck6) /\ (<>ck7)  

=============================================================================
\* Modification History
\* Last modified Wed May 30 20:38:30 ICT 2018 by Emp. Elesar II
\* Created Wed May 30 20:09:47 ICT 2018 by Emp. Elesar II
