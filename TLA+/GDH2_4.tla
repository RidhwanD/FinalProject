------------------------------ MODULE GDH2_mx ------------------------------

EXTENDS Integers, TLC, Sequences, ModExp

VARIABLES a0, a1, a2, a3, g, x0, x1, x2, x3, h0, h1, h2, h3, ul, ul2, ul3, bl, ck0, ck1, 
ck2, ck3, pc, p, key

vars == << a0, a1, a2, a3, g, x0, x1, x2, x3, h0, h1, h2, h3, ul, ul2, ul3, bl, ck0, ck1, 
ck2, ck3, pc, p, key >>

Init == (* Global variables *)
        /\ a0 \in Nat       (* Secret exponent of P0 *)
        /\ a1 \in Nat       (* Secret exponent of P1 *)
        /\ a2 \in Nat       (* Secret exponent of P2 *)
        /\ a3 \in Nat       (* Secret exponent of P3 *)
        /\ p = 13           (* Finite field size *)
        /\ g = 2            (* Generator of Fp *)
        /\ key = mod_exp(a3,mod_exp(a2,mod_exp(a1,mod_exp(a0,g,1,p),1,p),1,p),1,p) (* Shared key *)
        /\ x0 = 0           (* Value computed by P0 *)
        /\ x1 = 0           (* Value computed by P1 *)
        /\ x2 = 0           (* Value computed by P2 *)
        /\ x3 = 0           (* Value computed by P3 *)
        /\ h0 = 0           (* Number of message received by P0 *)
        /\ h1 = 0           (* Number of message received by P1 *)
        /\ h2 = 0           (* Number of message received by P2 *)
        /\ h3 = 0           (* Number of message received by P3 *)
        /\ ul = <<>>        (* Upflow list generated by P0 *)
        /\ ul2 = <<>>       (* Upflow list that has been updated by P1 *)
        /\ ul3 = <<>>       (* Upflow list that has been updated by P2 *)
        /\ bl = <<>>        (* Broadcast list generated by P3 *)        
        /\ ck0 = FALSE      (* Boolean to indicate that P0 has received the common key *)
        /\ ck1 = FALSE      (* Boolean to indicate that P1 has received the common key *)
        /\ ck2 = FALSE      (* Boolean to indicate that P2 has received the common key *)
        /\ ck3 = FALSE      (* Boolean to indicate that P3 has received the common key *)
        /\ pc = "Upflow"
        
Upflow == /\ pc = "Upflow" 
          /\ x0' = mod_exp(a0,g,1,p)    (* P0 calculates x0 = g ^ a0 mod p *)
          /\ ul' = <<x0'>>              (* P0 constructs the upflow list ul and sends it to P1*)
          /\ h1' = h1 + 1               (* P1 receives ul from P0, h1 increases by 1 *)
          /\ x1' = mod_exp(a1,ul'[1],1,p)(* P1 computes x1 = ul[1] ^ a1 mod p *)
          /\ ul2' = << x1', ul'[1], mod_exp(a1,g,1,p) >>   (* P1 updates upflow list ul as ul2 and sends it to P2 *)
          /\ h2' = h2 + 1               (* P2 receives ul2 from P1, h2 increases by 1 *)
          /\ x2' = mod_exp(a2,ul2'[1],1,p)(* P2 computes x2 = ul2[1] ^ a2 mod p *)
          /\ ul3' = << x2', ul2'[1], mod_exp(a2,ul2'[2],1,p), mod_exp(a2,ul2'[3],1,p) >>  
                                        (* P2 updates upflow list ul2 as ul3 and sends it to P3 *)
          /\ h3' = h3 + 1               (* P3 receives ul3 from P2, h3 increases by 1 *)
          /\ x3' = mod_exp(a3,ul3'[1],1,p)(* P3 computes x3 = ul3[1] ^ a3 mod p as its mutual key *)
          /\ bl' = << mod_exp(a3,ul3'[2],1,p), mod_exp(a3,ul3'[3],1,p), mod_exp(a3,ul3'[4],1,p) >>   
                                        (* P3 constructs broadcast list bl and broadcasts it to other participants *)
          /\ IF x0' = key /\ h0 = 1     (* If x0 equals key and P0 has received one message from others *)
                THEN /\ ck0' = TRUE     (* then ck0 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck0' = ck0
          /\ IF x1' = key /\ h1' = 2    (* If x1 equals key and P1 has received two messages from others *)
                THEN /\ ck1' = TRUE     (* then ck1 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck1' = ck1
          /\ IF x2' = key /\ h2' = 2    (* If x2 equals key and P2 has received two messages from others *)
                THEN /\ ck2' = TRUE     (* then ck2 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck2' = ck2
          /\ IF x3' = key /\ h3' = 1    (* If x3 equals key and P3 has received one message from others *)
                THEN /\ ck3' = TRUE     (* then ck3 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck3' = ck3
          /\ pc' = "Broadcast"          (* The upflow phase is finished, starts broadcast phase *)
          /\ UNCHANGED << a0, a1, a2, a3, g, p, key, h0 >>   
                                        (* The value of these variables are unchanged in this state *)
          
Broadcast == /\ pc = "Broadcast"
             /\ h2' = h2 + 1            (* P2 receives bl from P3, h2 increases by 1 *)
             /\ x2' = mod_exp(a2,bl[1],1,p)(* P2 computes x2 = bl[1] ^ a2 mod p as its mutual key *)
             /\ h1' = h1 + 1            (* P1 receives bl from P3, h1 increases by 1 *)
             /\ x1' = mod_exp(a1,bl[2],1,p)(* P1 computes x1 = bl[2] ^ a1 mod p as its mutual key *)
             /\ h0' = h0 + 1            (* P0 receives bl from P3, h0 increases by 1 *)
             /\ x0' = mod_exp(a0,bl[3],1,p)(* P0 computes x0 = bl[3] ^ a0 mod p as its mutual key *)
             /\ IF x0' = key /\ h0' = 1  (* If x0 equals key and P0 has received one message from others *)
                 THEN /\ ck0' = TRUE     (* then ck0 becomes TRUE *)
                 ELSE /\ TRUE
                      /\ ck0' = ck0
             /\ IF x1' = key /\ h1' = 2  (* If x1 equals key and P1 has received two messages from others *)
                 THEN /\ ck1' = TRUE     (* then ck1 becomes TRUE *)
                 ELSE /\ TRUE
                      /\ ck1' = ck1
             /\ IF x2' = key /\ h2' = 2  (* If x2 equals key and P2 has received two messages from others *)
                 THEN /\ ck2' = TRUE     (* then ck2 becomes TRUE *)
                 ELSE /\ TRUE
                      /\ ck2' = ck2
             /\ IF x3 = key /\ h3 = 1    (* If x3 equals key and P3 has received one message from others *)
                 THEN /\ ck3' = TRUE     (* then ck3 becomes TRUE *)
                 ELSE /\ TRUE
                      /\ ck3' = ck3
             /\ pc' = "Done"             (* The key exchange is finished *)
             /\ UNCHANGED << a0, a1, a2, a3, g, p, ul, ul2, ul3, bl, key, x3, h3 >>   
                                         (* The value of these variables are unchanged in this state *)

Next == Upflow \/ Broadcast
           \/ (* Disjunct to prevent deadlock on termination *)
              (pc = "Done" /\ UNCHANGED vars)

Spec == /\ Init /\ [][Next]_vars
        /\ WF_vars(Next)

(* Checking termination *)
Termination == <>(pc = "Done")     

(* Checking wether all participants eventually receive the key at the same time *)
SameTime == (<>(ck0 /\ ck1 /\ ck2 /\ ck3)) /\ (~<>(ck0 /\ (~ck1 \/ ~ck2 \/ ~ck3))) 
/\ (~<>(ck1 /\ (~ck0 \/ ~ck2 \/ ~ck3))) /\ (~<>(ck2 /\ (~ck0 \/ ~ck1 \/ ~ck3))) 
/\ (~<>(ck3 /\ (~ck0 \/ ~ck1 \/ ~ck2)))

(* Checking wether all participants eventually receive the key *)
GetMutualKey == (<>ck0) /\ (<>ck1) /\ (<>ck2) /\ (<>ck3)

=============================================================================
\* Modification History
\* Last modified Wed May 23 16:12:29 ICT 2018 by Emp. Elesar II
\* Created Wed May 23 16:06:48 ICT 2018 by Emp. Elesar II
