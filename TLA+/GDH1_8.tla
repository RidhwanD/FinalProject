------------------------------- MODULE GDH1_8 -------------------------------

EXTENDS Integers, TLC, Sequences, ModExp

PrimRoot(p) == {i \in 1..(p-1): \A j \in 1..(p-1): \E k \in 1..(p-1): i ^ k % p = j}
\* GetRoot(p) == CHOOSE i \in PrimRoot(p): TRUE

VARIABLES a0, a1, a2, a3, a4, a5, a6, a7, key, g, x0, x1, x2, x3, x4, x5, x6, x7, 
ul, ul2, ul3, ul4, ul5, ul6, ul7, dl, dl2, dl3, dl4, dl5, dl6, dl7, 
ck0, ck1, ck2, ck3, ck4, ck5, ck6, ck7, pc, p, h0, h1, h2, h3, h4, h5, h6, h7

vars == << a0, a1, a2, a3, a4, a5, a6, a7, key, g, x0, x1, x2, x3, x4, x5, x6, x7, 
ul, ul2, ul3, ul4, ul5, ul6, ul7, dl, dl2, dl3, dl4, dl5, dl6, dl7, 
ck0, ck1, ck2, ck3, ck4, ck5, ck6, ck7, pc, p, h0, h1, h2, h3, h4, h5, h6, h7 >>

Init == (* Global variables *)
        /\ a0 \in Nat       (* Secret exponent of S0 *)
        /\ a1 \in Nat       (* Secret exponent of S1 *)
        /\ a2 \in Nat       (* Secret exponent of S2 *)
        /\ a3 \in Nat       (* Secret exponent of S3 *)
        /\ a4 \in Nat       (* Secret exponent of S4 *)
        /\ a5 \in Nat       (* Secret exponent of S5 *)
        /\ a6 \in Nat       (* Secret exponent of S6 *)
        /\ a7 \in Nat       (* Secret exponent of S7 *)
        /\ p = 13           (* Finite field size *)
        /\ g = 2            (* Generator of Fp *)
        /\ key = mod_exp(a7,mod_exp(a6,mod_exp(a5,mod_exp(a4,mod_exp(a3,mod_exp(a2,mod_exp(a1,mod_exp(a0,g,1,p),1,p),1,p),1,p),1,p),1,p),1,p),1,p) 
                            (* Shared key *)
        /\ x0 = 0           (* Value computed by S0 *)
        /\ x1 = 0           (* Value computed by S1 *)
        /\ x2 = 0           (* Value computed by S2 *)
        /\ x3 = 0           (* Value computed by S3 *)
        /\ x4 = 0           (* Value computed by S4 *)
        /\ x5 = 0           (* Value computed by S5 *)
        /\ x6 = 0           (* Value computed by S6 *)
        /\ x7 = 0           (* Value computed by S7 *)
        /\ h0 = 0           (* Number of message received by S0 *)
        /\ h1 = 0           (* Number of message received by S1 *)
        /\ h2 = 0           (* Number of message received by S2 *)
        /\ h3 = 0           (* Number of message received by S3 *)
        /\ h4 = 0           (* Number of message received by S4 *)
        /\ h5 = 0           (* Number of message received by S5 *)
        /\ h6 = 0           (* Number of message received by S6 *)
        /\ h7 = 0           (* Number of message received by S7 *)
        /\ ck0 = FALSE      (* Boolean to indicate that S0 has received the common key *)
        /\ ck1 = FALSE      (* Boolean to indicate that S1 has received the common key *)
        /\ ck2 = FALSE      (* Boolean to indicate that S2 has received the common key *)
        /\ ck3 = FALSE      (* Boolean to indicate that S3 has received the common key *)
        /\ ck4 = FALSE      (* Boolean to indicate that S4 has received the common key *)
        /\ ck5 = FALSE      (* Boolean to indicate that S5 has received the common key *)
        /\ ck6 = FALSE      (* Boolean to indicate that S6 has received the common key *)
        /\ ck7 = FALSE      (* Boolean to indicate that S7 has received the common key *)
        /\ ul = <<>>        (* Upflow list generated by S0 *)
        /\ ul2 = <<>>       (* Upflow list that has been updated by S1 *)
        /\ ul3 = <<>>       (* Upflow list that has been updated by S2 *)
        /\ ul4 = <<>>       (* Upflow list that has been updated by S3 *)
        /\ ul5 = <<>>       (* Upflow list that has been updated by S4 *)
        /\ ul6 = <<>>       (* Upflow list that has been updated by S5 *)
        /\ ul7 = <<>>       (* Upflow list that has been updated by S6 *)
        /\ dl = <<>>        (* Downflow list generated by S7 *)        
        /\ dl2 = <<>>       (* Downflow list that has been updated by S6 *)
        /\ dl3 = <<>>       (* Downflow list that has been updated by S5 *)
        /\ dl4 = <<>>       (* Downflow list that has been updated by S4 *)
        /\ dl5 = <<>>       (* Downflow list that has been updated by S3 *)
        /\ dl6 = <<>>       (* Downflow list that has been updated by S2 *)
        /\ dl7 = <<>>       (* Downflow list that has been updated by S1 *)
        /\ pc = "Upflow"
        
Upflow == /\ pc = "Upflow"
          /\ x0' = mod_exp(a0,g,1,p)    (* S0 calculates x0 = g ^ a0 mod p *)
          /\ ul' = <<x0'>>              (* S0 generates upflow list ul with x0 as its member and sends it to S1 *)
          /\ h1' = h1 + 1               (* S1 receives ul from S0, h1 increases by 1 *)
          /\ x1' = mod_exp(a1,ul'[1],1,p)(* S1 computes x1 = ul[1] ^ a1 mod p *)
          /\ ul2' = Append(ul',x1')     (* S1 updates upflow list ul as ul2 by appending x1 and sends it to S2 *)
          /\ h2' = h2 + 1               (* S2 receives ul2 from S1, h2 increases by 1 *)
          /\ x2' = mod_exp(a2,ul2'[2],1,p)(* S2 computes x2 = ul2[2] ^ a2 mod p *)
          /\ ul3' = Append(ul2',x2')    (* S2 updates upflow list ul2 as ul3 by appending x2 and sends it to S3 *)
          /\ h3' = h3 + 1               (* S3 receives ul3 from S2, h3 increases by 1 *)
          /\ x3' = mod_exp(a3,ul3'[3],1,p)(* S3 computes x3 = ul3[3] ^ a3 mod p *)
          /\ ul4' = Append(ul3',x3')    (* S3 updates upflow list ul3 as ul4 by appending x3 and sends it to S4 *)
          /\ h4' = h4 + 1               (* S4 receives ul4 from S3, h4 increases by 1 *)
          /\ x4' = mod_exp(a4,ul4'[4],1,p)(* S4 computes x4 = ul4[4] ^ a4 mod p *)
          /\ ul5' = Append(ul4',x4')    (* S4 updates upflow list ul4 as ul5 by appending x4 and sends it to S5 *)
          /\ h5' = h5 + 1               (* S5 receives ul5 from S4, h5 increases by 1 *)
          /\ x5' = mod_exp(a5,ul5'[5],1,p)(* S5 computes x5 = ul5[5] ^ a5 mod p *)
          /\ ul6' = Append(ul5',x5')    (* S5 updates upflow list ul5 as ul6 by appending x5 and sends it to S6 *)
          /\ h6' = h6 + 1               (* S6 receives ul6 from S5, h6 increases by 1 *)
          /\ x6' = mod_exp(a6,ul6'[6],1,p)(* S6 computes x6 = ul6[6] ^ a6 mod p *)
          /\ ul7' = Append(ul6',x6')    (* S6 updates upflow list ul6 as ul7 by appending x6 and sends it to S7 *)
          /\ h7' = h7 + 1               (* S7 receives ul7 from S6, h7 increases by 1 *)
          /\ x7' = mod_exp(a7,ul7'[7],1,p)(* S7 computes x7 = ul7[7] ^ a7 mod p as its mutual key *)
          /\ dl' = << mod_exp(a7,g,1,p), mod_exp(a7,ul7'[1],1,p), mod_exp(a7,ul7'[2],1,p), mod_exp(a7,ul7'[3],1,p), mod_exp(a7,ul7'[4],1,p), mod_exp(a7,ul7'[5],1,p), mod_exp(a7,ul7'[6],1,p) >>  
                                        (* S3 constructs downflow list dl and sends it to S2 *)
          
          /\ IF x0' = key /\ h0 = 1     (* If x0 equals key and S0 has received one message from others *)
                THEN /\ ck0' = TRUE     (* then ck0 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck0' = ck0
          /\ IF x1' = key /\ h1' = 2    (* If x1 equals key and S1 has received two messages from others *)
                THEN /\ ck1' = TRUE     (* then ck1 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck1' = ck1
          /\ IF x2' = key /\ h2' = 2    (* If x2 equals key and S2 has received two messages from others *)
                THEN /\ ck2' = TRUE     (* then ck2 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck2' = ck2
          /\ IF x3' = key /\ h3' = 2    (* If x3 equals key and S3 has received two messages from others *)
                THEN /\ ck3' = TRUE     (* then ck3 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck3' = ck3
          /\ IF x4' = key /\ h4' = 2    (* If x4 equals key and S4 has received two messages from others *)
                THEN /\ ck4' = TRUE     (* then ck4 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck4' = ck4
          /\ IF x5' = key /\ h5' = 2    (* If x5 equals key and S5 has received two messages from others *)
                THEN /\ ck5' = TRUE     (* then ck5 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck5' = ck5
          /\ IF x6' = key /\ h6' = 2    (* If x6 equals key and S6 has received two messages from others *)
                THEN /\ ck6' = TRUE     (* then ck6 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck6' = ck6
          /\ IF x7' = key /\ h7' = 1    (* If x7 equals key and S7 has received one message from others *)
                THEN /\ ck7' = TRUE     (* then ck7 becomes TRUE *)
                ELSE /\ TRUE
                     /\ ck7' = ck7
                     
          /\ pc' = "Downflow"           (* The upflow phase is done, starts the downflow phase *)
          /\ UNCHANGED << a0, a1, a2, a3, a4, a5, a6, a7, g, p, dl2, dl3, dl4, dl5, dl6, dl7, key, h0 >>   
                                        (* The value of these variables are unchanged *)
          
Downflow == /\ pc = "Downflow"
            /\ h6' = h6 + 1             (* S6 receives dl from S7, h6 increases by 1 *)
            /\ x6' = mod_exp(a6,dl[7],1,p)(* S6 computes x6 = dl[7] ^ a6 mod p as its mutual key *)
            /\ dl2' = << mod_exp(a6,dl[1],1,p), mod_exp(a6,dl[2],1,p), mod_exp(a6,dl[3],1,p), mod_exp(a6,dl[4],1,p), mod_exp(a6,dl[5],1,p), mod_exp(a6,dl[6],1,p) >>    
                                        (* S6 updates downflow list dl as dl2 and sends it to S5 *)
            /\ h5' = h5 + 1             (* S5 receives dl2 from S6, h5 increases by 1 *)
            /\ x5' = mod_exp(a5,dl2'[6],1,p)(* S5 computes x5 = dl2[6] ^ a5 mod p as its mutual key *)
            /\ dl3' = << mod_exp(a5,dl2'[1],1,p), mod_exp(a5,dl2'[2],1,p), mod_exp(a5,dl2'[3],1,p), mod_exp(a5,dl2'[4],1,p), mod_exp(a5,dl2'[5],1,p) >>    
                                        (* S5 updates downflow list dl2 as dl3 and sends it to S4 *)
            /\ h4' = h4 + 1             (* S4 receives dl3 from S5, h4 increases by 1 *)
            /\ x4' = mod_exp(a4,dl3'[5],1,p)(* S4 computes x4 = dl3[5] ^ a4 mod p as its mutual key *)
            /\ dl4' = << mod_exp(a4,dl3'[1],1,p), mod_exp(a4,dl3'[2],1,p), mod_exp(a4,dl3'[3],1,p), mod_exp(a4,dl3'[4],1,p) >>    
                                        (* S4 updates downflow list dl3 as dl4 and sends it to S3 *)
            /\ h3' = h3 + 1             (* S3 receives dl4 from S4, h3 increases by 1 *)
            /\ x3' = mod_exp(a3,dl4'[4],1,p)(* S3 computes x3 = dl4[4] ^ a3 mod p as its mutual key *)
            /\ dl5' = << mod_exp(a3,dl4'[1],1,p), mod_exp(a3,dl4'[2],1,p), mod_exp(a3,dl4'[3],1,p) >>    
                                        (* S3 updates downflow list dl4 as dl5 and sends it to S2 *)
            /\ h2' = h2 + 1             (* S2 receives dl5 from S3, h2 increases by 1 *)
            /\ x2' = mod_exp(a2,dl5'[3],1,p)(* S2 computes x2 = dl5[3] ^ a2 mod p as its mutual key *)
            /\ dl6' = << mod_exp(a2,dl5'[1],1,p), mod_exp(a2,dl5'[2],1,p) >>    
                                        (* S2 updates downflow list dl5 as dl6 and sends it to S1 *)
            /\ h1' = h1 + 1             (* S1 receives dl6 from S2, h1 increases by 1 *)
            /\ x1' = mod_exp(a1,dl6'[2],1,p)(* S1 computes x1 = dl7[2] ^ a1 mod p as its mutual key *)
            /\ dl7' = << mod_exp(a1,dl6'[1],1,p) >>    (* S1 updates downflow list dl6 as dl7 and sends it to S0 *)
            /\ h0' = h0 + 1             (* S0 receives dl7 from S1, h0 increases by 1 *)
            /\ x0' = mod_exp(a0,dl7'[1],1,p)(* S0 computes x0 = dl7[1] ^ a0 mod p as its mutual key *)
            
            /\ IF x0' = key /\ h0' = 1    (* If x0 equals key and S0 has received one message from others *)
                  THEN /\ ck0' = TRUE     (* then ck0 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck0' = ck0
            /\ IF x1' = key /\ h1' = 2    (* If x1 equals key and S1 has received two messages from others *)
                  THEN /\ ck1' = TRUE     (* then ck1 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck1' = ck1
            /\ IF x2' = key /\ h2' = 2    (* If x2 equals key and S2 has received two messages from others *)
                  THEN /\ ck2' = TRUE     (* then ck2 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck2' = ck2
            /\ IF x3' = key /\ h3' = 2    (* If x3 equals key and S3 has received two messages from others *)
                  THEN /\ ck3' = TRUE     (* then ck3 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck3' = ck3
            /\ IF x4' = key /\ h4' = 2    (* If x4 equals key and S4 has received two messages from others *)
                  THEN /\ ck4' = TRUE     (* then ck4 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck4' = ck4
            /\ IF x5' = key /\ h5' = 2    (* If x5 equals key and S5 has received two messages from others *)
                  THEN /\ ck5' = TRUE     (* then ck5 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck5' = ck5
            /\ IF x6' = key /\ h6' = 2    (* If x6 equals key and S6 has received two messages from others *)
                  THEN /\ ck6' = TRUE     (* then ck6 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck6' = ck6
            /\ IF x7 = key /\ h7 = 1      (* If x7 equals key and S7 has received one message from others *)
                  THEN /\ ck7' = TRUE     (* then ck7 becomes TRUE *)
                  ELSE /\ TRUE
                       /\ ck7' = ck7
                     
            /\ pc' = "Done"             (* The key exchange is done *)
            /\ UNCHANGED << a0, a1, a2, a3, a4, a5, a6, a7, g, p, ul, ul2, ul3, ul4, ul5, ul6, ul7, dl, key, x7, h7 >>   
               (* The value of these variables are unchanged in this state *)

Next == Upflow \/ Downflow
           \/ (* Disjunct to prevent deadlock on termination *)
              (pc = "Done" /\ UNCHANGED vars)

Spec == /\ Init /\ [][Next]_vars
        /\ WF_vars(Next)

(* Checking termination *)
Termination == <>(pc = "Done")     

(* Checking wether all participants eventually receive the key at the same time *)
SameTime == (<>(ck0 /\ ck1 /\ ck2 /\ ck3 /\ ck4 /\ ck5 /\ ck6 /\ ck7)) 
/\ (~<>(ck0 /\ (~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7))) 
/\ (~<>(ck1 /\ (~ck0 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7))) 
/\ (~<>(ck2 /\ (~ck0 \/ ~ck1 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7))) 
/\ (~<>(ck3 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck4 \/ ~ck5 \/ ~ck6 \/ ~ck7)))
/\ (~<>(ck4 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck5 \/ ~ck6 \/ ~ck7)))
/\ (~<>(ck5 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck6 \/ ~ck7)))
/\ (~<>(ck6 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck7)))
/\ (~<>(ck7 /\ (~ck0 \/ ~ck1 \/ ~ck2 \/ ~ck3 \/ ~ck4 \/ ~ck5 \/ ~ck6)))

(* Checking wether all participants eventually receive the key *)
GetMutualKey == (<>ck0) /\ (<>ck1) /\ (<>ck2) /\ (<>ck3) /\ (<>ck4) /\ (<>ck5) /\ (<>ck6) /\ (<>ck7)      

=============================================================================
\* Modification History
\* Last modified Wed May 30 19:35:12 ICT 2018 by Emp. Elesar II
\* Created Wed May 30 18:31:58 ICT 2018 by Emp. Elesar II
